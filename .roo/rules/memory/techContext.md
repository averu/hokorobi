# 技術コンテキスト

## 使用されている技術

### コア技術

1. **React**

   - バージョン: 18.x
   - フック API の活用
   - Suspense とコンカレントモード
   - サーバーコンポーネントのサポート

2. **TypeScript**

   - 静的型付け
   - 型推論と型チェック
   - インターフェースと型定義
   - ジェネリクスの活用

3. **Vite**

   - 高速な開発サーバー
   - ES モジュールベースの HMR
   - ビルド最適化
   - プラグインエコシステム

4. **React Query / TanStack Query**

   - データフェッチングとキャッシュ
   - サーバー状態管理
   - 自動再取得と更新
   - ミューテーション処理

5. **Zod**

   - スキーマ検証
   - ランタイム型チェック
   - 型推論との連携
   - API レスポンスの検証

6. **React Router**
   - 宣言的なルーティング
   - ネストされたルート
   - ルートパラメータとクエリパラメータ
   - ローダーとアクション

### 状態管理

1. **Jotai**

   - プリミティブで柔軟なアトムベースの状態管理
   - React のコンテキストと Suspense との統合
   - 細かい粒度の再レンダリング最適化
   - 非同期アトムと派生アトムのサポート
   - デバッグツールとデベロッパーエクスペリエンス

2. **Context API**
   - コンポーネント間の状態共有
   - プロバイダーパターン
   - 機能ごとのコンテキスト分割

### テスト技術

1. **Vitest**

   - Vite と同じ設定を共有
   - Jest 互換 API
   - 高速な実行時間
   - Watch モードと UI
   - ファイルのコロケーションをサポート

2. **Testing Library**

   - ユーザー中心のテスト
   - クエリとインタラクション
   - アクセシビリティ優先のセレクタ
   - スクリーンとユーザーイベント

3. **MSW (Mock Service Worker)**
   - API モック
   - サービスワーカーベースのインターセプト
   - リアルなネットワークリクエスト
   - テスト環境での再利用

### スタイリング

1. **TailwindCSS**

   - ユーティリティファーストアプローチ
   - カスタマイズ可能な設計システム
   - パージとパフォーマンス最適化
   - ダークモードサポート

2. **Styled Components / Emotion**
   - CSS-in-JS
   - 動的スタイリング
   - テーマのサポート
   - コンポーネントベースの設計

### ビルドとツール

1. **ESLint**

   - コード品質と一貫性
   - TypeScript 統合
   - カスタムルールとプラグイン
   - 自動修正機能

2. **Prettier**

   - 一貫したコードフォーマット
   - エディタ統合
   - Git フック連携

3. **Husky + lint-staged**

   - Git フックの自動化
   - コミット前の検証
   - 段階的なリンティングとフォーマット

4. **GitHub Actions**
   - CI/CD パイプライン
   - 自動テストと検証
   - コード品質チェック
   - 自動デプロイ

## 開発環境のセットアップ

### 必要なツール

1. **Node.js のインストール**

   ```bash
   # nvm の使用を推奨
   nvm install 18
   nvm use 18

   # または直接インストール
   # https://nodejs.org/
   ```

2. **pnpm のインストール**

   ```bash
   npm install -g pnpm
   ```

3. **エディタ設定**

   - VSCode + 拡張機能の推奨
   - 設定例:

   ```json
   {
     "editor.formatOnSave": true,
     "editor.defaultFormatter": "esbenp.prettier-vscode",
     "editor.codeActionsOnSave": {
       "source.fixAll.eslint": true
     },
     "typescript.tsdk": "node_modules/typescript/lib",
     "tailwindCSS.includeLanguages": {
       "typescript": "javascript",
       "typescriptreact": "javascript"
     },
     "vitest.enable": true,
     "vitest.commandLine": "pnpm test"
   }
   ```

4. **プロジェクトのセットアップ**

   ```bash
   # リポジトリのクローン
   git clone <repository-url>
   cd <repository-directory>

   # 依存関係のインストール
   pnpm install

   # 開発サーバーの起動
   pnpm dev
   ```

### 開発ワークフロー

1. **新しいコンポーネントの作成**

   ```bash
   # コンポーネントの生成
   pnpm generate component MyComponent
   ```

2. **テストの実行**

   ```bash
   # すべてのテストの実行
   pnpm test

   # 特定のテストの実行
   pnpm test MyComponent

   # Watch モードでのテスト
   pnpm test:watch

   # UI モードでのテスト
   pnpm test:ui

   # カバレッジレポートの生成
   pnpm test:coverage
   ```

3. **リントとフォーマット**

   ```bash
   # リント
   pnpm lint

   # リントの自動修正
   pnpm lint:fix

   # フォーマット
   pnpm format
   ```

4. **ビルドと確認**

   ```bash
   # プロダクションビルド
   pnpm build

   # ビルド結果のプレビュー
   pnpm preview
   ```

## プロジェクト構造とコロケーション

```plaintext
src/
├── assets/            # 静的アセット
├── components/        # 共有コンポーネント
│   ├── Elements/      # 基本的なUI要素
│   │   ├── Button/
│   │   │   ├── Button.tsx           # コンポーネント実装
│   │   │   ├── Button.test.tsx      # コンポーネントテスト（コロケーション）
│   │   │   └── index.ts             # エクスポート
│   ├── Form/          # フォームコンポーネント
│   └── Layout/        # レイアウトコンポーネント
├── config/            # アプリケーション設定
├── features/          # 機能モジュール
│   └── users/
│       ├── api/                      # API 関連
│       │   ├── getUsers.ts           # APIリクエスト関数
│       │   ├── getUsers.test.ts      # APIテスト（コロケーション）
│       │   └── index.ts              # エクスポート
│       ├── components/               # 機能固有のコンポーネント
│       │   ├── UserList/
│       │   │   ├── UserList.tsx      # コンポーネント
│       │   │   ├── UserList.test.tsx # テスト（コロケーション）
│       │   │   └── index.ts          # エクスポート
│       ├── hooks/                    # カスタムフック
│       │   ├── useUsers.ts           # フック
│       │   ├── useUsers.test.ts      # フックテスト（コロケーション）
│       │   └── index.ts              # エクスポート
│       ├── routes/                   # ルート定義
│       ├── stores/                   # 状態管理（Jotai atoms）
│       │   ├── userAtoms.ts          # アトム定義
│       │   ├── userAtoms.test.ts     # アトムテスト（コロケーション）
│       │   └── index.ts              # エクスポート
│       ├── types/                    # 型定義
│       └── utils/                    # ユーティリティ関数
│           ├── formatUser.ts         # ユーティリティ
│           ├── formatUser.test.ts    # テスト（コロケーション）
│           └── index.ts              # エクスポート
├── hooks/             # グローバルなカスタムフック
├── lib/               # サードパーティライブラリのラッパー
├── providers/         # コンテキストプロバイダー
├── routes/            # アプリケーションルート
├── stores/            # グローバルなJotai atoms
│   ├── auth/                       # 認証関連のアトム
│   │   ├── authAtoms.ts            # 認証アトム
│   │   ├── authAtoms.test.ts       # アトムテスト（コロケーション）
│   │   └── index.ts                # エクスポート
│   ├── ui/                         # UI状態のアトム
│   │   ├── uiAtoms.ts              # UIアトム
│   │   ├── uiAtoms.test.ts         # アトムテスト（コロケーション）
│   │   └── index.ts                # エクスポート
├── test/              # テストユーティリティ
│   ├── mocks/         # モックデータとハンドラー (MSW, etc.)
│   │   ├── handlers.ts  # MSW リクエストハンドラー
│   │   ├── server.ts    # MSW サーバー設定 (Node.js 環境用)
│   │   └── browser.ts   # MSW サービスワーカー設定 (ブラウザ環境用)
│   ├── fixtures/      # テストフィクスチャ (定型データ)
│   │   └── user.ts    # ユーザー関連のフィクスチャ例
│   └── utils/         # テストヘルパー関数
│       └── render.tsx # カスタムレンダー関数例
├── types/             # グローバルな型定義
└── utils/             # ユーティリティ関数
    ├── formatters/              # フォーマッター関数
    │   ├── date.ts              # 日付フォーマッター
    │   ├── date.test.ts         # テスト（コロケーション）
    │   └── index.ts             # エクスポート
    └── validation/              # バリデーション関数
        ├── email.ts             # メールバリデーション
        ├── email.test.ts        # テスト（コロケーション）
        └── index.ts             # エクスポート
```

### ディレクトリの説明

1. **assets/**

   - アプリケーションで使用される静的アセット
   - 画像、アイコン、フォント等
   - SVG コンポーネントとして使用するものも含む

2. **components/**

   - アプリケーション全体で再利用可能な共通コンポーネント
   - 機能に依存しない純粋な UI コンポーネント
   - 各コンポーネントはそれぞれ独自のディレクトリを持ち、実装、テスト、インデックスファイルを含む

3. **config/**

   - アプリケーション設定
   - 環境変数の型定義
   - 機能フラグ
   - テーマ設定

4. **features/**

   - 機能別にモジュール化されたコード
   - 各機能は独自のコンポーネント、API、フック、ストア、型を持つ
   - ドメイン駆動設計の境界コンテキストに類似
   - 各ファイルのテストはコロケーションパターンで同じディレクトリに配置

5. **hooks/**

   - アプリケーション全体で使用されるカスタムフック
   - 各フックのテストは同じディレクトリに配置

6. **lib/**

   - サードパーティライブラリのラッパー
   - クライアントの抽象化
   - 依存性の分離と交換可能性の確保

7. **providers/**

   - アプリケーション全体のコンテキストプロバイダー
   - Jotai プロバイダー、クエリプロバイダー、認証プロバイダー等

8. **routes/**

   - アプリケーションのルート定義
   - ルーターの設定
   - レイアウトとページの構成

9. **stores/**

   - グローバルな Jotai アトム
   - 機能横断的な状態管理
   - アトムファミリーと派生アトム

10. **test/**

    - テスト用のユーティリティとヘルパー
    - **mocks/**: API モック (MSW) やその他のモック関連ファイルを配置。
    - **fixtures/**: テストで繰り返し使用される定型データ（フィクスチャ）を配置。ファクトリ関数などを含むことも。
    - **utils/**: カスタムレンダー関数やテスト固有のヘルパー関数を配置。

11. **types/**

    - グローバルな型定義
    - 型拡張
    - 型ユーティリティ

12. **utils/**
    - 純粋な関数のユーティリティ
    - ヘルパー関数
    - 各ユーティリティのテストはコロケーションパターンで同じディレクトリに配置

## Vitest とコロケーションの考慮事項

1. **ファイルのコロケーション**

   - テストファイルを実装ファイルと同じディレクトリに配置
   - 命名規則: `*.test.ts` または `*.test.tsx`
   - より密接な関連性とメンテナンスの容易さ

2. **Vitest の設定**

   ```typescript
   // vitest.config.ts
   import { defineConfig } from "vitest/config";
   import react from "@vitejs/plugin-react";
   import tsconfigPaths from "vite-tsconfig-paths";

   export default defineConfig({
     plugins: [react(), tsconfigPaths()],
     test: {
       globals: true,
       environment: "jsdom",
       setupFiles: ["./src/test/setup.ts"], // グローバルなセットアップファイル
       include: ["src/**/*.test.{ts,tsx}"],
       coverage: {
         provider: "v8", // or 'istanbul'
         reporter: ["text", "json", "html"],
         exclude: [
           "src/types/**",
           "src/**/*.d.ts",
           "src/test/**",
           "src/main.tsx", // エントリーポイントは除外することが多い
           "**/*.stories.tsx", // Storybook ファイルを除外
           "src/vite-env.d.ts",
         ],
         thresholds: {
           // (任意) カバレッジの閾値を設定
           lines: 80,
           functions: 80,
           branches: 80,
           statements: 80,
         },
       },
     },
   });
   ```

3. **テスト自動検出**

   - ファイル名パターンによる自動検出
   - glob パターン: `src/**/*.test.{ts,tsx}`
   - 特定のディレクトリ構造に依存しない柔軟な検出

4. **コロケーションの利点**

   - 実装とテストの密接な関係性
   - 変更時の影響範囲の明確化
   - 関連するコードの発見可能性向上
   - リファクタリング時の同時移動が容易

5. **コロケーションのベストプラクティス**
   - テストファイルは実装ファイルと同じディレクトリに配置
   - 関連するモックやフィクスチャーも同じディレクトリに配置可能（ただし、汎用的なものは `src/test` 以下に集約）
   - テストとソースコードの同期を維持
   - `index.ts` ファイルを使用してパブリック API をエクスポート

## 技術的制約

1. **React の制約**

   - レンダリングパフォーマンスの最適化
   - 副作用の管理
   - 深いコンポーネントツリーでのプロップドリル
   - サーバーコンポーネントの制限

2. **パフォーマンスの制約**

   - 初期ロード時間の最適化
   - バンドルサイズの管理
   - メモ化と再レンダリングの最小化
   - ビルド時間の最適化

3. **テストの制約**
   - コンポーネントの分離テスト
   - グローバル状態を持つコンポーネントのテスト
   - 非同期操作のテスト
   - ユーザーインタラクションのシミュレーション

## 依存関係

### 主要な依存関係

1. **コア**

   - `react`: UI 構築のコアライブラリ
   - `react-dom`: DOM レンダリング
   - `react-router-dom`: ルーティング
   - `@tanstack/react-query`: データフェッチング
   - `jotai`: 状態管理
   - `zod`: 検証

2. **UI コンポーネント**

   - `@headlessui/react`: アクセシブルな UI 要素
   - `@radix-ui/react-*`: プリミティブコンポーネント
   - `react-hook-form`: フォーム管理

3. **テスト**
   - `vitest`: テストランナー
   - `@testing-library/react`: コンポーネントテスト
   - `@testing-library/user-event`: ユーザーイベントシミュレーション
   - `msw`: API モック
   - `@testing-library/jest-dom`: DOM マッチャー
   - `@faker-js/faker`: (任意) テストデータ生成
   - `jest-axe`: (任意) アクセシビリティテスト

### 依存関係管理

1. **パッケージマネージャとして pnpm を使用**

   - 高速なインストール
   - ディスク効率の良いストレージ
   - 厳格な依存関係管理

2. **バージョン管理**

   - セマンティックバージョニングの遵守
   - `pnpm-lock.yaml` によるロック
   - 定期的な依存関係の更新

3. **依存関係のグルーピング**
   - ビルド依存関係
   - 開発依存関係
   - プロダクション依存関係
   - ピアー依存関係

## 技術的な意思決定

1. **Vite の採用理由**

   - **背景**: Create React App (CRA) や Webpack ベースのボイラープレートと比較し、開発体験の向上（特に起動速度と HMR）を重視。
   - **メリット**:
     - **高速な開発サーバー**: ネイティブ ES モジュールを利用し、バンドル不要なため、サーバー起動が非常に高速。
     - **高速な HMR**: モジュール単位での更新が可能で、アプリケーションの規模に関わらず HMR が高速に動作。
     - **効率的なビルド**: Rollup をベースとした本番ビルドは、最適化されており高速。
     - **シンプルな設定**: 多くの一般的な設定がデフォルトで組み込まれており、設定ファイル (`vite.config.ts`) が Webpack に比べて簡潔。
     - **豊富なプラグイン**: Rollup プラグインエコシステムとの互換性があり、必要な機能拡張が可能。
   - **トレードオフ**:
     - Webpack に比べるとエコシステム（特に特定のローダーやプラグイン）はまだ発展途上な部分もある。Webpack 特有の高度な設定やプラグインに依存しているプロジェクトからの移行は検討が必要。
     - 比較的新しいツールであるため、コミュニティの知見や解決策が Webpack ほど蓄積されていない可能性。
   - **将来**:
     - Vite のメジャーアップデートに追従し、最新の機能とパフォーマンス改善を活用。
     - プラグインの互換性や、新しい最適化手法の導入を継続的に評価。

2. **Vitest の採用理由**

   - **背景**: Jest が長らくデファクトスタンダードだったが、Vite プロジェクトとの親和性、設定の簡便さ、パフォーマンスを考慮し Vitest を選定。
   - **メリット**:
     - **Vite との統合**: Vite の設定 (`vite.config.ts`) を共有できるため、テスト環境の構築が非常に容易。トランスパイルやパスエイリアスなどの設定を二重管理する必要がない。
     - **Jest 互換 API**: Jest に慣れている開発者にとって学習コストが低く、既存の Jest テストからの移行も比較的容易 (`describe`, `it`, `expect` など)。
     - **高速な実行**: Vite の高速性を活かし、テストの実行が非常に速い。特に Watch モードでの差分実行が効率的。
     - **優れた開発者体験**: 高機能な Watch モード、インタラクティブな UI モード (`vitest --ui`)、インソーステストなどの機能を提供。
     - **ネイティブ ESM サポート**: Vite 同様、ESM をネイティブでサポート。
     - **TypeScript/JSX サポート**: 追加設定なしで TypeScript と JSX をサポート。
   - **トレードオフ**:
     - Jest ほどのエコシステムや長年の実績はないため、特定の高度な Jest プラグインや機能が必要な場合は代替手段を探す必要がある可能性。
     - 一部の Jest API や挙動（例: グローバル setup/teardown の一部）とは微妙な差異が存在する場合がある。
   - **将来**:
     - Vitest のアップデートに追従し、新しいアサーションやテスト機能を取り入れる。
     - カバレッジレポートやテスト結果の分析を通じて、テストスイートの品質を継続的に改善。

3. **コロケーションパターンの採用理由**

   - **背景**: 従来、テストコードを `src/tests` や `__tests__` のような別のディレクトリにまとめて配置するアプローチもあったが、実装コードとテストコードが物理的に離れていると、関連性の把握や同時編集が煩雑になることがあった。コロケーションパターン（実装ファイルと同じディレクトリにテストファイルを配置する）は、この問題を解決し、コンポーネントやモジュールの独立性を高めることを目的として採用。
   - **メリット**:
     - **実装とテストの近接性**: 実装コード (`*.ts`, `*.tsx`) とそれに対応するテストコード (`*.test.ts`, `*.test.tsx`) が同じディレクトリに存在するため、関連性が一目でわかり、ファイル間の移動や参照が容易になる。
     - **コードの発見可能性**: 特定のコンポーネントやモジュールに関連するすべてのファイル（実装、テスト、スタイル、ストーリーブックファイルなど）が同じ場所に集まるため、コードベースのナビゲーションが容易になる。
     - **変更の影響範囲の明確化**: あるコンポーネントやモジュールを変更する際、関連するテストも同じディレクトリにあるため、テストの更新漏れを防ぎやすい。
     - **リファクタリングの容易さ**: コンポーネントやモジュールを移動・リネームする際に、関連するテストファイルも一緒に移動・リネームすればよいため、作業が簡潔になる。
     - **モジュール性**: 各コンポーネント/モジュールが自己完結しやすくなり、再利用性や独立性が向上する。
   - **デメリット/トレードオフ**:
     - **ディレクトリのファイル数増加**: 各ディレクトリに含まれるファイル数が多くなる可能性がある。ただし、機能ベースのフォルダ構造と組み合わせることで、全体の複雑さは管理可能と判断。
     - **ビルド/テスト設定**: テストランナーやビルドツールが、ソースディレクトリ内のテストファイルを適切に認識し、処理（または除外）するように設定する必要がある (Vitest はデフォルトで `*.test.*` を認識するため問題少ない)。
   - **適用例**:
     - `src/components/Elements/Button/Button.tsx` と `src/components/Elements/Button/Button.test.tsx`
     - `src/features/todos/api/getTodos.ts` と `src/features/todos/api/getTodos.test.ts`
     - `src/features/todos/stores/todoAtoms.ts` と `src/features/todos/stores/todoAtoms.test.ts`
   - **将来**:
     - プロジェクトの規模が非常に大きくなった場合、テストファイルのみをサブディレクトリ (`__tests__`) に配置するなどの微調整を検討する可能性はあるが、現時点では直接的なコロケーションが最適と判断。
     - ストーリーブックファイル (`*.stories.tsx`) など、他の関連ファイルも同様にコロケーションする方針を維持する。

4. **機能ベースのフォルダ構造 (`src/features`) の採用理由**

   - **背景**: 従来のレイヤーベース構造（例: `src/components`, `src/containers`, `src/services`）では、機能変更時に複数のディレクトリを横断する必要があり、関連コードの把握が困難になる傾向があった。機能ベース構造は、関連するコードを一つの場所にまとめることで、この問題を解決する。
   - **メリット**:
     - **高い凝集度**: 機能に関連するコンポーネント、API クライアント、状態管理ロジック、型定義、テストなどが `src/features/<feature-name>` ディレクトリ内に集約されるため、機能の全体像を把握しやすい。
     - **低い結合度**: 各機能モジュールは他の機能モジュールから可能な限り独立しており、変更の影響範囲が限定される。これにより、リファクタリングや機能改修が容易になる。
     - **スケーラビリティ**: 新機能の追加は新しい `features` ディレクトリを作成するだけで済み、既存コードへの影響を最小限に抑えられる。プロジェクトが大規模化しても構造が破綻しにくい。
     - **チーム開発の効率化**: 機能単位で開発担当者を割り当てやすく、コードの所有権が明確になるため、コンフリクトのリスクを低減できる。
     - **コードの発見可能性**: 特定の機能に関するコードを探す際に、`src/features` 以下を探索すればよいため、効率が良い。
   - **デメリット**:
     - **共有モジュールの設計**: 複数の機能で共通して利用されるコンポーネント (`src/components`) やフック (`src/hooks`)、ユーティリティ (`src/utils`) の設計と配置場所の判断が重要になる。どこまでを共有とし、どこからを機能固有とするかの境界線引きが難しい場合がある。
     - **機能の粒度**: 「機能」の粒度をどの程度にするかの定義が曖昧だと、ディレクトリが細分化されすぎたり、逆に一つのディレクトリが肥大化したりする可能性がある。
     - **循環参照のリスク**: 機能間で意図しない依存関係（特に循環参照）が発生しないよう、モジュール間のインターフェース設計に注意が必要。`index.ts` によるエクスポート制御が有効。
   - **トレードオフ**: レイヤーベース構造に比べ、初期段階ではディレクトリ構造がやや複雑に見える可能性がある。しかし、プロジェクトの成長に伴い、機能ベース構造の方が管理しやすくなると判断。
   - **将来**: プロジェクトの進化に合わせて、機能の分割・統合や、共有モジュールのリファクタリングを継続的に行う。機能間の依存関係を可視化するツール（例: `dependency-cruiser`）の導入も検討。

5. **TanStack Query の採用理由**

   - **背景**: 従来の `useEffect` と `useState` を用いたデータフェッチングは、キャッシュ管理、ローディング/エラー状態の処理、再取得ロジックなどが煩雑になりがちだった。SWR や Apollo Client と比較し、REST API との親和性、柔軟な設定、DevTools の使いやすさから TanStack Query を選定。
   - **利点**:
     - サーバー状態とクライアント状態を明確に分離し、関心の分離を促進。
     - 強力なキャッシュ機構 (`stale-while-revalidate`) により、不要な API コールを削減し、UI の応答性を向上。
     - ローディング (`isLoading`, `isFetching`)、エラー (`isError`, `error`) 状態を自動で管理し、ボイラープレートコードを削減。
     - `useMutation` フックにより、データの作成・更新・削除処理と、関連するクエリの無効化・再取得を宣言的に記述可能。
     - 楽観的更新 (Optimistic Updates) をサポートし、ユーザー体験を向上させることが可能。
     - React Query DevTools により、キャッシュの状態やクエリのライフサイクルを視覚的にデバッグ可能。
     - `queryClient` を通じて、アプリケーション全体でクエリのキャッシュを操作・管理できる。
   - **トレードオフ**:
     - `useEffect` ベースのフェッチングに比べると、初期学習コストがかかる。
     - キャッシュ戦略（`staleTime`, `cacheTime` など）の適切な設定がパフォーマンスに影響するため、理解が必要。
     - グローバルな `queryClient` の設定や、テストでの `QueryClientProvider` の設定が必要。
   - **将来**:
     - アプリケーションの特性に合わせて、より高度なキャッシュ戦略や `gcTime` の調整を検討。
     - 必要に応じて、Persister プラグインを使用したキャッシュの永続化を検討。
     - GraphQL API を導入する場合は、Apollo Client など他のライブラリとの比較検討を再度行う可能性あり。

6. **Jotai の採用理由**

   - **背景**: Redux Toolkit や Zustand と比較検討した結果、よりシンプルな API とアトミックな状態管理モデルが、当プロジェクトの求めるコンポーネントの独立性と再利用性に合致すると判断。
   - **利点**:
     - プリミティブなアトムベースのアプローチにより、学習コストが比較的低い。
     - 状態の更新が必要なコンポーネントのみが再レンダリングされるため、パフォーマンス最適化に貢献（例: `TodoList` コンポーネントでの不要な再レンダリング抑制）。
     - React Suspense との親和性が高く、非同期状態の管理が容易。
     - TypeScript との相性が良く、型安全な状態管理を実現。
     - Recoil に似た API を持ちつつ、バンドルサイズが小さい。
     - 派生アトム (`atomWith*` など) を活用することで、複雑な状態ロジックを宣言的に記述可能（例: `filteredTodoListAtom`）。
   - **トレードオフ**: 大規模な状態ツリーや複雑なミドルウェア連携が必要な場合は、Redux Toolkit の方が適している可能性もあるが、現時点では Jotai のシンプルさがメリットと判断。
   - **将来**: アプリケーションの規模拡大に伴い、アトムの管理戦略（命名規則、ディレクトリ構成など）を継続的に見直す必要がある。

7. **Zod の採用理由**

   - **背景**: TypeScript はコンパイル時の型チェックを提供するが、API レスポンス、フォーム入力、ローカルストレージなど、外部から受け取るデータの型は実行時まで保証されない。このギャップを埋め、ランタイムでの型安全性を確保するためにスキーマ検証ライブラリが必要となった。Yup や Joi と比較し、TypeScript との親和性の高さ、API のシンプルさ、型推論機能の強力さから Zod を選定。
   - **メリット**:
     - **TypeScript ファースト**: スキーマ定義から TypeScript の型を `z.infer<typeof schema>` で自動推論できるため、型定義とバリデーションロジックの二重管理が不要になり、コードの整合性が保たれる。
     - **ランタイム安全性**: API レスポンスやフォーム入力など、信頼できないデータを扱う際に、期待するデータ構造であることを実行時に検証し、予期せぬエラーを防ぐ。
     - **表現力豊かなスキーマ**: 文字列、数値、日付、オブジェクト、配列、Union 型、Intersection 型など、複雑なデータ構造も柔軟に定義可能。`.refine()` によるカスタムバリデーションや `.transform()` によるデータ変換もサポート。
     - **明確なエラー**: バリデーション失敗時に、どのフィールドでどのようなエラーが発生したかを示す詳細なエラー情報を提供するため、デバッグやユーザーへのフィードバックが容易。
     - **軽量**: 依存関係が少なく、バンドルサイズへの影響が比較的小さい。
   - **適用例**:
     - API レスポンスデータの検証: `fetch` や TanStack Query の `queryFn` 内でレスポンスデータを `schema.parse()` または `schema.safeParse()` を使って検証し、期待通りの形式であることを保証する。
     - フォーム入力のバリデーション: React Hook Form などのフォームライブラリと連携し (`@hookform/resolvers/zod`)、入力値のリアルタイムまたは送信時のバリデーションを行う。
     - 環境変数の検証: アプリケーション起動時に環境変数を Zod スキーマで検証し、設定ミスを防ぐ。
   - **トレードオフ**:
     - すべての外部データに対してスキーマを定義・適用する必要があるため、開発工数がわずかに増加する。
     - 非常に動的で予測不可能なデータ構造を扱う場合、スキーマ定義が複雑になる可能性がある。
   - **将来**:
     - Zod のエコシステム（例: `zod-to-json-schema` など）を活用し、他のツールとの連携を強化する可能性。
     - プロジェクト全体で共通のカスタムバリデーションルールやエラーメッセージ形式を定義し、一貫性を保つ。

8. **TailwindCSS の採用理由**

   - **背景**: 従来の CSS 設計手法（BEM、CSS Modules、CSS-in-JS など）と比較し、開発速度、一貫性、保守性の観点からユーティリティファーストのアプローチを検討。Styled Components や Emotion などの CSS-in-JS も候補だったが、ランタイムオーバーヘッドの懸念と、HTML 構造内でスタイルを完結させたい意向から TailwindCSS を選定。
   - **メリット**:
     - **開発速度の向上**: 事前定義されたユーティリティクラスを組み合わせることで、CSS を書く時間を大幅に削減し、迅速なプロトタイピングと UI 実装が可能。
     - **デザインの一貫性**: `tailwind.config.js` で定義されたデザインシステム（色、スペーシング、フォントサイズなど）に基づいたクラスのみを使用するため、UI 全体で一貫性を保ちやすい。
     - **保守性の向上**: スタイルが HTML 要素に直接適用されるため、CSS の影響範囲が明確で、意図しないスタイルの衝突やグローバルな影響を心配する必要が少ない。コンポーネント単位でのスタイルのカプセル化が容易。
     - **パフォーマンス**: 本番ビルド時に PurgeCSS (JIT モード) によって未使用のクラスが自動的に削除されるため、最終的な CSS バンドルサイズが非常に小さくなる。
     - **レスポンシブデザイン**: `sm:`, `md:`, `lg:` などのプレフィックスを使って、ブレークポイントごとのスタイル変更を直感的に記述できる。
     - **状態に応じたスタイル**: `:hover`, `:focus`, `:disabled` などの状態バリアントや、ダークモード (`dark:`) などの条件付きスタイルを容易に適用できる。
   - **デメリット/トレードオフ**:
     - **HTML の肥大化**: 多くのユーティリティクラスを適用すると、HTML のクラス属性が長くなり、可読性が低下する可能性がある。(`@apply` やコンポーネント抽出で緩和可能)
     - **学習コスト**: ユーティリティクラス名を覚える必要がある（ただし、エディタの補完機能でカバーできる）。従来の CSS の書き方とは異なるため、慣れが必要。
     - **独自のデザインシステム構築**: プロジェクト固有の複雑なデザインシステムを構築する場合、`tailwind.config.js` のカスタマイズやプラグイン開発が必要になることがある。
     - **「ユーティリティクラスの乱用」**: 規律がないと、コンポーネント間で一貫性のないスタイルが適用される可能性がある。コンポーネント化や `@apply` の適切な利用が重要。
   - **適用例**:
     - アプリケーション全体のレイアウト、ボタン、フォーム要素、カードなどの基本的な UI コンポーネントのスタイリング。
     - レスポンシブ対応やダークモード対応の実装。
     - プロトタイピング段階での迅速な UI 構築。
   - **将来**:
     - TailwindCSS のバージョンアップに追従し、新しいユーティリティや機能を取り入れる。
     - プロジェクトの成長に合わせて、`tailwind.config.js` の設定やカスタムプラグインを見直す。
     - 必要に応じて、Headless UI や Radix UI などのコンポーネントライブラリと組み合わせて利用する。

## Jotai を使用した状態管理戦略

1. **アトムの定義**

   - 状態の最小単位としてアトムを定義
   - `atom()` 関数を使用
   - 初期値と型を指定

2. **アトムのスコープ**

   - グローバルアトム: `src/stores`
   - 機能固有アトム: `src/features/*/stores`
   - コンポーネントローカルアトム: 必要に応じてコンポーネント内で定義

3. **派生アトム**

   - `atom()` の読み取り専用バージョンを使用
   - 他のアトムから計算された状態を定義
   - 例: フィルタリングされたリスト、計算された合計値

4. **非同期アトム**

   - `atom()` の非同期バージョンを使用
   - 非同期操作（API 呼び出しなど）の結果を管理
   - Suspense との統合

5. **アクションアトム**

   - `atom()` の書き込み専用バージョンを使用
   - 状態更新ロジックをカプセル化
   - 副作用の実行

6. **アトムファミリー**

   - `atomFamily()` を使用
   - パラメータ化されたアトムのコレクションを作成
   - 動的なリストやアイテムの状態管理

7. **ユーティリティ**

   - `atomWithStorage`: ローカルストレージとの同期
   - `atomWithQuery`: React Query との統合
   - `selectAtom`: アトムの一部を選択

8. **テスト**
   - `renderHook` と `act` を使用してアトムの動作をテスト
   - `Provider` を使用してテスト環境でアトムを初期化

## テスト戦略

1. **テストの種類と詳細**

   - **単体テスト (Unit Tests)**:
     - **対象**: 純粋関数 (例: `src/utils` 内のフォーマッター、バリデーター)、カスタムフック内の純粋なロジック部分、Jotai アトムの更新ロジックや派生アトムの計算ロジック。UI や副作用から分離されたロジックを重点的にテストする。
     - **ツール**: Vitest (`describe`, `it`, `expect`)。必要に応じて `vi.fn()` でモック関数を作成。
     - **目的**: 特定の入力に対して期待される出力や状態遷移が正しく行われるか、エッジケースやエラーケースを含めて検証する。実行速度が速いため、最も多く記述する。
     - **ポイント**: 依存関係は積極的にモック (`vi.mock`) し、テスト対象のユニットを隔離する。
   - **コンポーネントテスト (Component Tests)**:
     - **対象**: 個別の React コンポーネント (`src/components`, `src/features/*/components`)。特に再利用可能な UI 要素や、状態を持つコンポーネント。
     - **ツール**: Vitest + Testing Library (`render`, `screen`, `userEvent`)。
     - **目的**: コンポーネントが特定の props や内部状態に基づいて正しくレンダリングされるか、ユーザーインタラクション（クリック、入力など）に対して期待通りに反応するかを検証する。
     - **ポイント**: 実装の詳細（内部状態やメソッド）ではなく、ユーザーがどのようにコンポーネントを操作し、何を見るかに焦点を当てる。アクセシビリティを考慮し、`getByRole`, `getByLabelText` などのセマンティックなクエリを優先的に使用する。インタラクションは `userEvent` を使用し、実際のユーザー操作を模倣する。必要に応じて `jest-axe` を連携させ、アクセシビリティ違反を検出する。
   - **統合テスト (Integration Tests)**:
     - **対象**: 複数のコンポーネント、フック、状態管理（Jotai）、ルーティング（React Router）が連携して動作するユーザーフローや機能単位。例: フォーム入力から送信までの流れ、リスト表示とフィルタリング・ソート機能、認証フローの一部など。API 通信を伴う場合は MSW で API レスポンスをモックする。
     - **ツール**: Vitest + Testing Library + MSW。
     - **目的**: 個々のユニットが連携し、機能全体として期待通りに動作することをユーザー視点で検証する。単体テストやコンポーネントテストでは捉えきれない、モジュール間のインタラクションの問題を発見する。
     - **ポイント**: ページ全体や主要な機能コンポーネントを `render` し、実際のユーザー操作に近いシナリオを実行する。MSW のハンドラー (`src/test/mocks/handlers.ts`) を適切に設定し、テストごとに必要な API モックレスポンスを提供する。状態の変更や画面遷移なども含めて検証する。
   - **E2E テスト (End-to-End Tests)**:
     - **対象**: アプリケーション全体の主要なユーザーストーリーやクリティカルパス。例: ユーザー登録からログイン、主要機能の利用、ログアウトまでの一連の流れ。
     - **ツール**: Playwright または Cypress (現時点では未導入、必要に応じて検討)。
     - **目的**: 実際のブラウザ環境で、フロントエンドと（必要であれば）実際のバックエンド API を含めたシステム全体が、ユーザーの視点から期待通りに動作することを確認する。
     - **ポイント**: 実行コスト（時間、環境構築）が高いため、テストケース数は最小限に抑え、最も重要なシナリオに限定する。UI の細かい見た目ではなく、主要な機能が壊れていないかを検証することに主眼を置く。CI/CD パイプラインの最終段階（例: ステージング環境へのデプロイ後）での実行を想定する。

2. **テストの原則**

   - **Test Pyramid**: 単体テストを最も多く、コンポーネントテスト、統合テストと続き、E2E テストを最も少なく記述するバランスを意識する。
   - **ユーザー中心**: 特にコンポーネントテストと統合テストでは、Testing Library の思想に基づき、実装の詳細ではなくユーザーの視点からテストを記述する。
   - **FIRST**: テストは **F**ast (高速)、**I**ndependent (独立)、**R**epeatable (再現可能)、**S**elf-Validating (自己検証可能)、**T**imely (適時) であるべき。
   - **カバレッジ**: コードカバレッジ (目標: 80%以上) を品質の一指標とするが、カバレッジの数値だけを追うのではなく、テストの内容と質を重視する。カバレッジレポート (`pnpm test:coverage`) を定期的に確認し、テストが不足している箇所を特定する。

3. **テストの書き方**

   - **命名規則**:
     - テストファイル: 実装ファイル名に `.test` を付与 (例: `Button.test.tsx`)。
     - `describe` ブロック: テスト対象のユニット（コンポーネント名、フック名、関数名など）を記述 (例: `describe('Button', () => { ... })`)。必要に応じてネストし、テストのコンテキストを明確にする (例: `describe('when disabled', () => { ... })`)。
     - `it` (または `test`) ブロック: テストケースの具体的な振る舞いや期待される結果を記述する。"should" から始める英語で記述することを推奨 (例: `it('should render correctly with default props', () => { ... })`, `it('should call onClick handler when clicked', () => { ... })`)。
   - **構造 (Arrange-Act-Assert)**:
     - **Arrange (準備)**: テストに必要な前提条件をセットアップする。
       - コンポーネントテスト: `render` 関数でコンポーネントを描画し、必要な props を渡す。
       - 単体テスト: テスト対象の関数に必要な引数やモックを設定する。
       - 統合テスト: 必要なプロバイダー (Router, QueryClient, Jotai Provider など) でラップしてレンダリングし、MSW ハンドラーを設定する。
     - **Act (実行)**: テスト対象のコードを実行する。
       - コンポーネントテスト: `userEvent` を使ってユーザーインタラクション（クリック、入力など）をシミュレートする。
       - 単体テスト: テスト対象の関数を呼び出す。
       - フックテスト: `renderHook` を使用し、フックのロジックを実行する。
     - **Assert (検証)**: 実行結果が期待通りであることを検証する。
       - `expect` と Vitest/Jest DOM のマッチャー (`toBeInTheDocument`, `toHaveTextContent`, `toHaveBeenCalledWith` など) を使用して、DOM の状態、関数の戻り値、モックの呼び出しなどを検証する。
       - スナップショットテスト (`toMatchSnapshot`) は、UI の意図しない変更を検出する目的で補助的に使用するが、依存しすぎないように注意する。変更が頻繁なコンポーネントには不向き。
   - **ヘルパー関数**:
     - 複数のテストで共通して利用されるセットアップロジック（例: 特定のプロバイダーでラップしてレンダリングする関数、MSW の共通ハンドラー設定）や、カスタムクエリ、カスタムマッチャーなどは `src/test/utils` ディレクトリにヘルパー関数として抽出し、テストコードの重複を減らし、可読性と保守性を向上させる。
     - 例: `renderWithProviders(<MyComponent />)` のようなカスタムレンダー関数。

4. **モックとテストデータ管理**

   - **API モック (MSW)**:
     - ネットワークレベルでの API モックには MSW を使用する。
     - 共通のハンドラーは `src/test/mocks/handlers.ts` に定義する。
     - テスト固有のハンドラーやレスポンスの上書きは、各テストファイル内で `server.use()` を使用して行う。
     - テスト実行前に `server.listen()`、各テスト後に `server.resetHandlers()`、全テスト後に `server.close()` を呼び出す設定を `src/test/setup.ts` で行う。
   - **依存関係モック (Vitest)**:
     - `vi.mock('module-path', () => ({ ... }))` を使用して、テスト対象が依存するモジュールや関数をモックする。
     - `vi.fn()` を使用して、関数の呼び出しや引数をスパイする。
     - `vi.spyOn()` を使用して、既存のオブジェクトのメソッドをスパイまたはモックする。
   - **テストデータ/フィクスチャ**:
     - **目的**: テストで繰り返し使用される定型的なデータ構造（例: API レスポンスの型、特定の状態を持つユーザーオブジェクト）を定義し、テストコードの冗長性を減らし、一貫性を保つ。
     - **管理場所**:
       - 汎用的なフィクスチャやファクトリ関数は `src/test/fixtures` ディレクトリに配置する (例: `src/test/fixtures/user.ts`)。
       - 特定のコンポーネントや機能に固有のフィクスチャは、テストファイルと同じディレクトリに配置することも許容する。
     - **形式**:
       - 単純なデータは TypeScript のオブジェクトリテラルや配列として定義する。
       - 複雑なデータやバリエーションが必要な場合は、**ファクトリ関数**パターンを推奨する。引数で一部のプロパティを上書きできるように設計する (例: `createUser({ isAdmin: true })`)。
       - 必要に応じて、`@faker-js/faker` などのライブラリを導入し、リアルなダミーデータを動的に生成することも検討する。
     - **利用**: テストの Arrange フェーズでフィクスチャをインポートし、MSW のレスポンスやコンポーネントの props として使用する。

5. **CI/CD におけるテスト実行戦略**

   - **トリガー**:
     - **Pull Request (PR) / Merge Request (MR)**: フィーチャーブランチからメインブランチ（例: `main`, `develop`）へのマージリクエストが作成/更新された際に実行。
     - **Push to Main Branch**: メインブランチに直接プッシュされた際（または PR がマージされた際）に実行。
     - **(任意) Nightly Build**: 定期的に（例: 毎晩）実行。
   - **実行するテスト**:
     - **PR/MR 時**:
       - リンティング (ESLint) とフォーマットチェック (Prettier)。
       - **単体テスト** (`pnpm test:unit` または関連コマンド)。
       - **コンポーネントテスト** (`pnpm test:component` または関連コマンド)。
       - **統合テスト** (`pnpm test:integration` または関連コマンド)。
       - 目的: 開発中のコード変更が既存の機能やコンポーネントを破壊していないかを迅速に確認する。フィードバックサイクルを短く保つため、比較的実行時間の短いテストを中心に実行する。
     - **Push to Main Branch 時**:
       - PR/MR 時のテストに加えて、
       - **(任意) E2E テスト**: 主要なユーザーストーリーをカバーする E2E テストを実行。
       - **(任意) ビジュアルリグレッションテスト (VRT)**: UI の意図しない変更を検出。
       - 目的: メインブランチのコードが常に安定しており、デプロイ可能な状態であることを保証する。より網羅的なテストを実行する。
     - **(任意) Nightly Build 時**:
       - より広範囲な E2E テストや、時間のかかるパフォーマンステストなどを実行。
   - **失敗時の対応**:
     - PR/MR 時のテスト失敗: マージをブロックし、開発者に修正を促す。GitHub Actions の結果を PR 上で確認できるようにする。
     - Main Branch 時のテスト失敗: 関連チームに通知（Slack 通知など）し、迅速な原因調査と修正を促す。必要に応じてデプロイをロールバックする仕組みも検討。
   - **レポート**:
     - テスト結果: CI/CD プラットフォーム (GitHub Actions など) 上でテスト結果のサマリーと詳細を確認できるようにする。
     - カバレッジレポート: テスト実行後にカバレッジレポートを生成し、アーティファクトとして保存する。Codecov や Coveralls などの外部サービスと連携し、PR 上でカバレッジの変化を確認できるようにすることも推奨。

6. **カバレッジとその他のテスト**
   - **コードカバレッジ**:
     - **目標**: 全体として 80% 以上のカバレッジを目指すが、これはあくまで目安であり、テストの質が最も重要。重要なビジネスロジックや複雑な分岐を持つ箇所は、より高いカバレッジを目指す。
     - **計測**: `pnpm test:coverage` コマンドでカバレッジレポート (text, json, html) を生成する。`vitest.config.ts` でカバレッジプロバイダー (`v8` または `istanbul`) や除外ファイル、閾値を設定できる。
     - **解釈**: カバレッジレポートは、テストされていないコード行を特定するためのツールとして活用する。100% カバレッジが必ずしも高品質なテストを意味するわけではないことに注意する（テストケースが不十分な場合もある）。
     - **向上**: カバレッジが低い箇所を特定し、テストケースを追加する。特に、エラーハンドリング、エッジケース、条件分岐などを網羅するように意識する。ただし、単純なゲッター/セッターや定数定義など、テストする価値が低いコードまで無理にカバレッジを上げる必要はない。
   - **アクセシビリティテスト (a11y)**:
     - **目的**: すべてのユーザーがアプリケーションを利用できるよう、アクセシビリティ標準 (WCAG など) を満たしていることを確認する。
     - **方法**:
       - コンポーネントテスト内で `jest-axe` を使用し、レンダリングされた DOM に対して自動的にアクセシビリティ違反をチェックする。テストヘルパー (`src/test/utils/render.tsx` など) に組み込むことを推奨。
       - ESLint プラグイン (`eslint-plugin-jsx-a11y`) を導入し、静的解析の段階で潜在的な問題を検出する。
       - 手動テスト（キーボード操作、スクリーンリーダーでの確認）も定期的に実施する。
     - **CI**: CI パイプラインに `jest-axe` を含むテストステップを組み込み、マージ前にアクセシビリティ違反がないかを確認する。
   - **ビジュアルリグレッションテスト (VRT)**:
     - **目的**: UI コンポーネントやページの見た目が意図せず変更されていないか（リグレッション）を検出する。
     - **方法**:
       - Storybook と Chromatic などの VRT サービスを連携させる。コンポーネントの各状態を Storybook で定義し、Chromatic が自動でスクリーンショットを比較し、差分を検出・レビューする。
       - Playwright や Cypress などの E2E テストツールが提供するスクリーンショット比較機能を利用する。
     - **導入検討**: VRT は UI の品質維持に有効だが、設定やメンテナンス（特にスナップショットの更新管理）にコストがかかる。プロジェクトの要件やリソースに応じて導入を検討する。特に、共通コンポーネントライブラリやデザインシステムを開発している場合に有効。

## パフォーマンス最適化

1. **バンドルサイズの削減**

   - コード分割 (React.lazy, dynamic import)
   - Tree Shaking (Vite による自動最適化)
   - 依存関係の分析 (例: `vite-plugin-visualizer`)
   - 不要なライブラリの削除

2. **レンダリングパフォーマンス**

   - `React.memo`, `useMemo`, `useCallback` の適切な使用
   - 不要な再レンダリングの特定 (React DevTools Profiler)
   - Jotai による細かい粒度の状態更新
   - 仮想リスト (例: `react-window`, `react-virtualized`) の検討

3. **データ取得**

   - TanStack Query によるキャッシュとバックグラウンド更新
   - 必要なデータのみを取得
   - 楽観的更新 (Optimistic Updates) の活用

4. **初期ロード**

   - 画像の最適化 (フォーマット、サイズ)
   - フォント読み込み戦略
   - Service Worker によるキャッシュ (PWA 化)

5. **計測と監視**
   - Lighthouse, WebPageTest によるパフォーマンス計測
   - React DevTools Profiler によるボトルネック特定
   - 本番環境での RUM (Real User Monitoring) の導入検討
